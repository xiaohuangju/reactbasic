<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <template id="foo"> 
        <p>I'm inside a template!</p> 
       </template> 

  </body>
  <script>
    /*
    1、标记清除法 用的多
    2、引用计数法  很少用
    3、性能
       垃圾回收是周期性运行的，如果内存中分配了很多的变量，就会造成性能损失
       ，因此垃圾回收的时间调度很重要，尤其在移动设备上，垃圾回收会拖慢渲染和帧速度
       （无论什么时候开始收集垃圾，都能尽快的结束工作）
    4、内存管理 
        在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，JavaScript 运行在一个内存
        管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动
        浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量 JavaScript 的网页耗尽系
        统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程
        中执行的语句数量。
        将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行
        代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫
        作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用
       4.1 let 与const 声明提升性能，可以更早的让垃圾回收介入，尽早回收内存
       4.2  隐藏类和删除操作
                。V8 在将解释后的 JavaScript
            代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很
            重要

        4.3内存泄漏
        4.4 静态分配与对象池
    
    */
    console.log(document.querySelector('#foo').content); 
    let fragment=document.querySelector('#foo').content
    console.log(fragment.querySelector('p')); // <p>...<p> 
    console.log(window);

    let a=null;
    console.log([1,2,2] instanceof Object)
  </script>
</html>
