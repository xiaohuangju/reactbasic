<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /*
数组的创建方式  let arr=[] let arr=new Array() let arr=Array
1、创建数组  字面量不调用构造函数
2、检测数组  value instanceof Array  或者 Array.isArray()
3、迭代器方法   keys()   values()  entries()
4、复制和填充    copyWithin()  fill()
5、转换方法  toLocaleString() toString() valueOf()
6、静态方法  from()    of() 
7、数组进行浅复制 
8、栈方法   LIFO  push（添加） pop（删除） 栈尾 改变原数组
9、队列方法  FIFO  shift(移走) unshift（添加） 队头 改变原数组
10、排序方法  reverse (翻转)  sort（排序 compare） 改变原数组
11、操作方法  concat(数组[Symbol.isConcatSpreadable]=false 不展平)  新数组
             slice  获取通过索引 不要结束   新数组
             splice  删除 插入 替换 改变原数组
12、搜索和位置方法
   严格相等  indexOf  lastIndexOf  includes()
   断言相等   find findIndex  (元素，索引，数组本身)
13、迭代方法  every  filter  forEach map  some   (数组元素，元素索引，数组本身)、
14、并归方法  reduce()  reduceRight()
*/

    let result = [
      {
        flowId: "2F409D46B14A000",
        flowNo: "02",
        flowName: "DSR机器人流程",
        flowType: "IT_FLOW_CLASS_TYPE_02",
        isValid: "IS_ISEF_001",
        version: "",
        isDeleted: "FALSE",
        createdId: "ADMIN",
        createdTime: "",
        updatedId: "",
        updatedTime: "",
      },
      {
        flowId: "2F409E70384A000",
        flowNo: "03",
        flowName: "产品合规审核",
        flowType: "IT_FLOW_CLASS_TYPE_03",
        isValid: "IS_ISEF_001",
        version: "",
        isDeleted: "FALSE",
        createdId: "ADMIN",
        createdTime: "",
        updatedId: "",
        updatedTime: "",
      },
      {
        flowId: "2F409E74394A000",
        flowNo: "01",
        flowName: "DSR人工流程",
        flowType: "IT_FLOW_CLASS_TYPE_01",
        isValid: "IS_ISEF_001",
        version: "",
        isDeleted: "FALSE",
        createdId: "ADMIN",
        createdTime: "",
        updatedId: "",
        updatedTime: "",
      },
      {
        flowId: "3403B6418950000",
        flowNo: "04",
        flowName: "组件评审流程",
        flowType: "IT_FLOW_CLASS_TYPE_04",
        isValid: "IS_ISEF_001",
        version: "",
        isDeleted: "FALSE",
        createdId: "ADMIN",
        createdTime: "",
        updatedId: "",
        updatedTime: "",
      },
    ];

    /*1=====================================*/
    let array = ["first", "second", 3, 4, ["one", "two"], [[7, 8]], ,];
    let concatArr = ["apple", "banana", ["a", "b"]];
    let arrayConstructor = new Array();
    let arrayConstructor2 = new Array(2);
    let arrayConstructor3 = new Array(1, 2, 3, 4, 5);

    /*2===================================*/
    let isArr = array instanceof Array;
    let isArr2 = Array.isArray(array);

    /*3======================================*/
    let arrayKeys = array.keys();
    let arrayValues = array.values();
    let arrayEntries = array.entries();
    /*返回的是一个迭代器对象 
      Array Iterator {} 
      [[Prototype]]: Array Iteratornext: ƒ next()length: 0name: "next"arguments: （…）
      caller: （…）
      [[Prototype]]: ƒ ()
      [[Scopes]]: Scopes[0]Symbol(Symbol.toStringTag): "Array Iterator"[[Prototype]]: Object，
      */
    /*对象转数组============================*/

    /*扩展运算符++++++++++++++*/
    let translateArrKeys1 = [...arrayKeys];
    let translateArrValue1 = [...arrayValues];
    let translateArrEntries1 = [...arrayEntries];

    /*

    Array.from方法对一个+++++++++++++++++++
    （类似数组）
    或
    （可迭代对象）  keys()  values() Entries()返回的就是一个迭代器对象即可迭代的对象
    Set 和Map 返回的也是迭代对象
    创建一个新的，(浅拷贝的数组实例)
    */
    let translateArrKeys = Array.from(arrayKeys);
    let translateArrValue = Array.from(arrayValues);
    let translateArrEntries = Array.from(arrayEntries);

    const set = new Set(["foo", "bar"]);
    const map = new Map([
      [1, 2],
      [3, 4],
    ]);
    Array.from("foo");
    Array.from(set);
    Array.from(map);

    /*5============================================
    toLocaleString (字符串)  每个元素都会调用toLocaleString方法
    toString（字符产）  每个元素都会去调用toString方法
    valueOf（数组） 即数组本省
    继承于Object
    */
    array.toLocaleString();
    array.toString();
    array.valueOf();

    /*8==========================================
    栈方法 push pop*/
    array.push("push追加元素");
    array.pop();

    /*9================================
    shift
    unshift
        队列方法
    */
    array.shift();
    array.unshift("unshift添加元素");

    /*10==============================
    排序
     reverse
    sort 内部先调用的是toString()方法进行对比
    */

    function compare(value1, value2) {
      if (value1 > value2) {
        return -1;
      } else if (value1 < value2) {
        return 1;
      } else {
        return 0;
      }
    }
    let numArr = [3, 2, 41, 354, 3, 5, 7];
    array.reverse();
    array.sort();
    numArr.sort(compare);

    /*11========================================
    操作方法
    {
      concat(新数组)
      flat  平展的层次
    }  
    默认不平展 [Symbol.isConcatSpreadable]=false   (只平展第一层)
    类数组 (array-like) 对象，默认展开。期望展开其元素用于连接，需要设置 Symbol.isConcatSpreadable 为 true：
    var fakeArray = {
      [Symbol.isConcatSpreadable]: true,
      length: 2,
      0: "hello",
      1: "world"
              };

    slice（新数组）  以索引为切片  
    splice   （删除，替换（当替换0则为插入），）
    */
    concatArr[Symbol.isConcatSpreadable] = true;
    let newconcatArr = array.concat(concatArr);
    let newflat = newconcatArr.flat(1);
    let sliceArr = newflat.slice(1, 3);
    newflat.splice(1, 3, "改变原数组填补替换元素"); //第一个位置，删除三个

    console.time();
    //分类
    function classifily(data) {
      let newAr = [];
      data.forEach((item) => {
        let copyItem = item;
        let itemGroupId = copyItem.groupId;
        let isElem = newAr.some((elem) => {
          return elem.groupId == itemGroupId;
        });
        if (isElem) {
          newAr.forEach((el) => {
            if (el.groupId == itemGroupId) {
              el.list.push(copyItem);
            }
          });
        } else {
          newAr.push({ groupId: itemGroupId, list: [copyItem] });
        }
      });
      //中英文归类
      // const lanaugeClassifyFn = (itemlist) => {
      //   let itemlists = JSON.parse(JSON.stringify(itemlist));
      //   let newItemlist = [];
      //   itemlists.map((item) => {
      //     let copyItem = item;
      //     let itemQuestionTitle = copyItem.questionInfo.title;
      //     let isSameTitle = newItemlist.some((ele) => {
      //       return ele?.title == itemQuestionTitle;
      //     });
      //     if (isSameTitle) {
      //       newItemlist.find((v) => {
      //         if (v?.title == itemQuestionTitle) {
      //           v.list.push(item);
      //         }
      //       });
      //     } else {
      //       newItemlist.push({ title: itemQuestionTitle, list: [item] });
      //     }
      //   });
      //   return newItemlist;
      // };
      // newAr = newAr.map((ele) => {
      //   let eleList = ele.list;
      //   eleList = lanaugeClassifyFn(eleList);
      //   return ele;
      // });
      return newAr;
    }
    console.log(classifily(arrPra));
    console.timeEnd();
  </script>
</html>
