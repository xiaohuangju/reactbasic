<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /*
数组的创建方式  let arr=[] let arr=new Array() let arr=Array
1、创建数组  字面量不调用构造函数
2、检测数组  value instanceof Array  或者 Array.isArray()
3、迭代器方法   keys()   values()  entries()
4、复制和填充    copyWithin()  fill()
5、转换方法  toLocaleString() toString() valueOf()
6、静态方法  from()    of() 
7、数组进行浅复制 
8、栈方法   LIFO  push（添加） pop（删除） 栈尾 改变原数组
9、队列方法  FIFO  shift(移走) unshift（添加） 队头 改变原数组
10、排序方法  reverse (翻转)  sort（排序 compare） 改变原数组
11、操作方法  concat(数组[Symbol.isConcatSpreadable]=false 不展平)  新数组
             slice  获取通过索引 不要结束   新数组
             splice  删除 插入 替换 改变原数组
12、搜索和位置方法
   严格相等  indexOf  lastIndexOf  includes()
   断言相等   find findIndex  (元素，索引，数组本身)
13、迭代方法  every  filter  forEach map  some   (数组元素，元素索引，数组本身)、
14、并归方法  reduce()  reduceRight()


*/
    console.log(Array.from("matt"));
    console.log([..."sasa"]);
    const m = new Map();
    m.set(1, 2);
    console.log(m);
    console.log(Array.from(m));
    const n = new Set();
    n.add(1);
    n.add(2);
    console.log(Array.from(n), "n");

    const a1 = [1, 2, 3];
    const a2 = Array.from(a1);
    console.log(a1, "a1进行浅复制");
    //argument转数组
    function getArgsArray() {
      return Array.from(arguments);
    }
    console.log(getArgsArray(1, 2, 3, 4, { a: "213" }));
    const arrayLikeObject = {
      0: 0,
      1: 1,
      length: 2,
    };
    console.log(Array.from(arrayLikeObject));

    const b = ["foo", "bar", "baz", "qux"];
    const akey = Array.from(b.keys());
    const valueArr = Array.from(b.values());
    const entries = Array.from(b.entries());
    console.log(entries, "entries");
    console.log(valueArr, "values");
    console.log(akey, "keys==");

    for (const [index, element] of entries) {
      console.log(element, "elememt=");
    }
    const zeroes = [0, 0, 0, 0, 0, 0, 0, { b: 22 }];
    zeroes.fill(5);
    zeroes.fill(6, 3);
    zeroes.fill(8, 1, 3);
    console.log(zeroes, "zeroes");

    let newArr = [1, 2, , "aaa"];
    let newArr2 = Array.from(newArr, (x) => {
      return x + 1;
    });
    console.log(newArr2, "newArr2");
    let obj2 = { a: 1, b: 2 };
    let obj3 = Array.of(obj2);
    console.log(obj3, "obj3");
    let isArray = Array.isArray(obj2);
    console.log(newArr instanceof Array);
    console.log(isArray, "isArray");
    let new3 = newArr.copyWithin(5);
    console.log(new3, "new3");

    console.log(newArr.valueOf(), newArr.toString(), newArr.toLocaleString());

    let person1 = {
      toLocaleString() {
        return "Niko";
      },
      toString() {
        return "nico";
      },
    };
    let person2 = {
      toLocaleString() {
        return "dsad";
      },
      toString() {
        return "dss";
      },
    };
    let people = [person1, person2];
    console.log(people.toString(), people.toLocaleString());

    let newOj = { a: "2", b: "e" };
    console.log(newOj.toLocaleString(), newOj.toString());

    /*栈方法（后进先出 last In first out）  push pop改变原数组*/
    let zhanArr = ["first", "second", "three", "foure"];
    zhanArr.push("five");
    zhanArr.pop();

      /*队列方法( first in first out)   shift unshift*/
    zhanArr.shift();
    zhanArr.unshift('aaa','bbb')
    console.log(zhanArr, "zhanarr");

  /*排序方法 reverse() sort()
  sort()实质是调用 String()方法转型函数
  
  */

  function compare(value1,value2){
    if(value1<value2){
      return 1;
    }else if(value1>value2){
      return -1;
    }else{
      return 0;
    }
  }
  let values=[0,4,2,3,6,7];
  console.log(values.sort(compare));
/*操作方法  concat()*/

let colors=['red','green','blue'];
let colors2=colors.concat('yellow',["black",'brown']);
console.log(colors);
console.log(colors2,'colors2');//默认是展开
let newColor=['black','brown']
let newMoreColor={
  [Symbol.isConcatSpreadable]:true,
  length:2,
  0:'pink',
  1:"cy"
}
console.log(colors,'newColor')
newColor[Symbol.isConcatSpreadable]=false;
let newColor2=colors.concat('cc',newColor);
let colors3=colors.concat(newMoreColor);
console.log(colors);
console.log(newColor2);
console.log(colors3)


let sliceColor=colors.slice(1,2);
console.log(colors,sliceColor);
/*splice 主要目的是在数组中插入元素
*/
let spliceColor=[1,2,3,4,5,6]
spliceColor.splice(0,0,'first');
console.log(spliceColor,'color')


const evens=[4,2,4,6,4];
evens.find((element,index,arr)=>{
  console.log(element,index,arr)
  return element===4
})

let newenv=evens.reduce((pre,cur,index,arr)=>{
  return pre+cur
})
console.log(newenv,evens)
  </script>
</html>
